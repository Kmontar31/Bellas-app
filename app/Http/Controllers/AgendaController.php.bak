<?php

namespace App\Http\Controllers;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;
use App\Models\Agenda;
use App\Models\Cliente;
use App\Models\Profesional;
use App\Models\Servicio;
use App\Models\Bloqueo;
use App\Models\Horario;
use Illuminate\Support\Str;
use Carbon\Carbon;
use Illuminate\Support\Facades\DB;

class AgendaController extends Controller
{
    /**
     * Display a listing of the resource.
     */
    public function index()
    {
        $profesionales = Profesional::all();
        $servicios = Servicio::all();
        $citas = Agenda::with(['cliente', 'profesional', 'servicio'])
            ->orderBy('fecha', 'asc')
            ->orderBy('hora_inicio', 'asc')
            ->get();

        return view('admin.agenda.index', compact('citas', 'profesionales', 'servicios'));
    }

    /**
     * Mostrar calendario para administración
     */
    public function calendar()
    {
        return view('admin.agenda.calendar');
    }

    /**
     * Endpoint JSON para eventos (FullCalendar)
     */
    public function events(Request $request)
    {
        $start = $request->query('start') ? Carbon::parse($request->query('start')) : Carbon::now();
        $end = $request->query('end') ? Carbon::parse($request->query('end')) : Carbon::now()->addMonth();
        $profesionalId = $request->query('profesional_id');
        $servicioId = $request->query('servicio_id');
        
        $events = [];
        
        $events = [];

        // 1. Obtener citas
        $citas = Agenda::with(['cliente', 'profesional', 'servicio'])
            ->whereBetween('fecha', [$start->toDateString(), $end->toDateString()])
            ->when($profesionalId, function($query) use ($profesionalId) {
                return $query->where('profesional_id', $profesionalId);
            })
            ->when($servicioId, function($query) use ($servicioId) {
                return $query->where('servicio_id', $servicioId);
            })->get();

        foreach ($citas as $cita) {
            $citaStart = Carbon::parse($cita->fecha->format('Y-m-d') . ' ' . $cita->hora_inicio);
            $citaEnd = Carbon::parse($cita->fecha->format('Y-m-d') . ' ' . $cita->hora_fin);

            $events[] = [
                'id' => $cita->id,
                'title' => ($cita->cliente ? $cita->cliente->nombre . ' - ' : '') . 
                          ($cita->servicio ? $cita->servicio->nombre : 'Cita'),
                'start' => $citaStart->toIso8601String(),
                'end' => $citaEnd->toIso8601String(),
                'extendedProps' => [
                    'profesional' => optional($cita->profesional)->nombre,
                    'servicio' => optional($cita->servicio)->nombre,
                    'estado' => $cita->estado ?? null,
                    'tipo' => 'cita',
                    'cliente' => optional($cita->cliente)->nombre
                ],
                'className' => 'ocupado'
            ];
        }

        // 2. Obtener horarios disponibles
        $horarios = Horario::with('profesional')
            ->when($profesionalId, function($query) use ($profesionalId) {
                return $query->where('profesional_id', $profesionalId);
            })->get();

        // Generar eventos de horarios disponibles
        $currentDate = clone $start;
        while ($currentDate <= $end) {
            foreach ($horarios as $horario) {
                if ($currentDate->dayOfWeek == $horario->dia_semana) {
                    $events[] = [
                        'title' => 'Disponible - ' . $horario->profesional->nombre,
                        'start' => $currentDate->format('Y-m-d') . ' ' . $horario->hora_inicio,
                        'end' => $currentDate->format('Y-m-d') . ' ' . $horario->hora_fin,
                        'className' => 'disponible',
                        'rendering' => 'background'
                    ];
                }
            }
            $currentDate->addDay();
        }

        // 3. Obtener bloqueos
        $bloqueos = Bloqueo::whereBetween('fecha', [$start->toDateString(), $end->toDateString()])
            ->when($profesionalId, function($query) use ($profesionalId) {
                return $query->where(function($q) use ($profesionalId) {
                    $q->where('profesional_id', $profesionalId)
                      ->orWhereNull('profesional_id');
                });
            })->get();

        foreach ($bloqueos as $bloqueo) {
            $events[] = [
                'id' => 'b-' . $bloqueo->id,
                'title' => 'Bloqueado' . ($bloqueo->profesional ? ' - ' . $bloqueo->profesional->nombre : ''),
                'start' => $bloqueo->fecha->toDateString(),
                'end' => Carbon::parse($bloqueo->fecha)->addDay()->toDateString(),
                'allDay' => true,
                'extendedProps' => [
                    'block' => true,
                    'tipo' => 'bloqueo',
                    'motivo' => $bloqueo->motivo,
                    'profesional' => optional($bloqueo->profesional)->nombre
                ],
                'className' => 'bloqueado'
            ];
        }

        return response()->json($events);
    }

        // Convertir citas a eventos
        foreach ($citas as $cita) {
            $title = ($cita->cliente ? $cita->cliente->nombre . ' - ' : '') . ($cita->servicio ? $cita->servicio->nombre : 'Cita');
            $start = $cita->fecha ? Carbon::parse($cita->fecha->toDateString() . ' ' . Carbon::parse($cita->hora_inicio)->format('H:i:s')) : null;
            $end = $cita->fecha ? Carbon::parse($cita->fecha->toDateString() . ' ' . Carbon::parse($cita->hora_fin)->format('H:i:s')) : null;

            return [
                'id' => $cita->id,
                'title' => $title,
                'start' => $start ? $start->toIso8601String() : null,
                'end' => $end ? $end->toIso8601String() : null,
                'extendedProps' => [
                    'profesional' => $cita->profesional ? $cita->profesional->nombre : null,
                    'servicio' => $cita->servicio ? $cita->servicio->nombre : null,
                    'estado' => $cita->estado ?? null,
                    'block' => false,
                    'tipo' => 'cita',
                    'cliente' => $cita->cliente ? $cita->cliente->nombre : null,
                    'notas' => $cita->notas
                ],
                'editable' => true,
            ];
        })->toArray();

        // Obtener horarios disponibles
        $horarios = Horario::when($profesionalId, function($query) use ($profesionalId) {
            return $query->where('profesional_id', $profesionalId);
        })->get();

        // Generar eventos de horarios disponibles
        $horariosEvents = collect();
        foreach ($horarios as $horario) {
            $currentDate = Carbon::parse($start);
            $endDate = Carbon::parse($end);

            while ($currentDate <= $endDate) {
                if ($currentDate->dayOfWeek == $horario->dia_semana) {
                    $horariosEvents->push([
                        'title' => 'Disponible - ' . $horario->profesional->nombre,
                        'start' => $currentDate->format('Y-m-d') . ' ' . $horario->hora_inicio,
                        'end' => $currentDate->format('Y-m-d') . ' ' . $horario->hora_fin,
                        'extendedProps' => [
                            'profesional' => $horario->profesional->nombre,
                            'tipo' => 'disponible'
                        ],
                        'rendering' => 'background',
                        'className' => 'disponible'
                    ]);
                }
                $currentDate->addDay();
            }
        }

        // Añadir bloqueos como eventos allDay
        $bloqueosQuery = Bloqueo::query();
        if ($start && $end) {
            $bloqueosQuery->whereBetween('fecha', [$start->toDateString(), $end->toDateString()]);
        }
        // Convertir bloqueos a eventos
        foreach ($bloqueos as $b) {
            return [
                'id' => 'b-' . $b->id,
                'title' => 'Bloqueado',
                'start' => $b->fecha->toDateString(),
                'allDay' => true,
                'color' => '#d9534f',
                'extendedProps' => [
                    'block' => true,
                    'bloqueo_id' => $b->id,
                    'motivo' => $b->motivo,
                    'profesional' => $b->profesional ? $b->profesional->nombre : 'Todos los profesionales',
                ],
                'editable' => false,
            ];
        })->toArray();

        $merged = array_merge($events, $bloqueos);

        return response()->json($merged);
    }

    /**
     * Reprogramar cita (respuesta a eventDrop)
     */
    public function updateEvent(Request $request, Agenda $agenda)
    {
        $data = $request->validate([
            'start' => 'required|date',
            'end' => 'nullable|date',
        ]);

        $start = Carbon::parse($data['start']);
        $end = isset($data['end']) ? Carbon::parse($data['end']) : null;

        $profesionalId = $agenda->profesional_id;

        // calcular nuevos campos
        $newFecha = $start->toDateString();
        $newHoraInicio = $start->format('H:i:s');

        if ($end) {
            $newHoraFin = $end->format('H:i:s');
        } else {
            // intentar usar duración del servicio
            $duracion = $agenda->servicio ? ($agenda->servicio->duracion_minutos ?? 30) : 30;
            $newHoraFin = $start->copy()->addMinutes($duracion)->format('H:i:s');
        }

        // validar solapamiento
        $overlap = Agenda::where('id', '!=', $agenda->id)
            ->where('profesional_id', $profesionalId)
            ->where('fecha', $newFecha)
            ->where(function ($q) use ($newHoraInicio, $newHoraFin) {
                $q->whereBetween('hora_inicio', [$newHoraInicio, $newHoraFin])
                  ->orWhereBetween('hora_fin', [$newHoraInicio, $newHoraFin])
                  ->orWhere(function ($q2) use ($newHoraInicio, $newHoraFin) {
                      $q2->where('hora_inicio', '<=', $newHoraInicio)
                         ->where('hora_fin', '>=', $newHoraFin);
                  });
            })->exists();

        if ($overlap) {
            return response()->json(['message' => 'Solapamiento con otra cita.'], 422);
        }

        // comprobar bloqueo en esa fecha
        $bloqueado = Bloqueo::where('fecha', $newFecha)->exists();
        if ($bloqueado) {
            return response()->json(['message' => 'La fecha está bloqueada y no se puede reprogramar.'], 422);
        }

        $agenda->fecha = $newFecha;
        $agenda->hora_inicio = $newHoraInicio;
        $agenda->hora_fin = $newHoraFin;
        $agenda->save();

        return response()->json(['message' => 'Cita reprogramada correctamente.']);
    }

    /**
     * Formulario público para reservar turno
     */
    public function publicCreate()
    {
        $profesionales = Profesional::all();
        $servicios = Servicio::all();
        return view('booking.create', compact('profesionales', 'servicios'));
    }

    /**
     * Guardar reserva desde formulario público (validando disponibilidad)
     */
    public function publicStore(Request $request)
    {
        $data = $request->validate([
            'nombre' => 'required|string|max:255',
            'email' => 'required|email|max:255',
            'telefono' => 'nullable|string|max:20',
            'profesional_id' => 'required|exists:profesionales,id',
            'servicio_id' => 'required|exists:servicios,id',
            'fecha' => 'required|date',
            'hora_inicio' => 'required|date_format:H:i',
        ]);

        // evitar reservar en días bloqueados
        if (Bloqueo::where('fecha', $data['fecha'])->exists()) {
            return back()->withInput()->withErrors(['fecha' => 'La fecha seleccionada está bloqueada y no está disponible para reservas.']);
        }

        // Calcular hora_fin según duración del servicio
        $servicio = Servicio::find($data['servicio_id']);
        $duracion = $servicio->duracion_minutos ?? 30;
        $horaInicio = Carbon::createFromFormat('H:i', $data['hora_inicio']);
        $horaFin = $horaInicio->copy()->addMinutes($duracion)->format('H:i:s');

        // Verificar disponibilidad para el profesional en ese rango
        $overlap = Agenda::where('profesional_id', $data['profesional_id'])
            ->where('fecha', $data['fecha'])
            ->where(function ($q) use ($data, $horaInicio, $horaFin) {
                $q->whereBetween('hora_inicio', [$horaInicio->format('H:i:s'), $horaFin])
                  ->orWhereBetween('hora_fin', [$horaInicio->format('H:i:s'), $horaFin])
                  ->orWhere(function ($q2) use ($horaInicio, $horaFin) {
                      $q2->where('hora_inicio', '<=', $horaInicio->format('H:i:s'))
                         ->where('hora_fin', '>=', $horaFin);
                  });
            })->exists();

        if ($overlap) {
            return back()->withInput()->withErrors(['hora_inicio' => 'La profesional no está disponible en ese horario.']);
        }

        // Crear o buscar cliente por email
        $cliente = Cliente::firstOrCreate(
            ['email' => $data['email']],
            ['nombre' => $data['nombre'], 'telefono' => $data['telefono'] ?? null]
        );

        $cita = Agenda::create([
            'cliente_id' => $cliente->id,
            'profesional_id' => $data['profesional_id'],
            'servicio_id' => $data['servicio_id'],
            'fecha' => $data['fecha'],
            'hora_inicio' => $horaInicio->format('H:i:s'),
            'hora_fin' => $horaFin,
            'estado' => 'confirmada',
            'notas' => null,
        ]);

        return redirect()->route('booking.thanks')->with('success', 'Reserva creada correctamente.');
    }

    /**
     * Crear bloqueo (día no disponible)
     */
    public function blocksStore(Request $request)
    {
        $data = $request->validate([
            'fecha' => 'required|date',
            'motivo' => 'nullable|string|max:255',
            'profesional_id' => 'nullable|exists:profesionales,id',
        ]);

        $exists = Bloqueo::where('fecha', $data['fecha'])
                        ->when($data['profesional_id'], function($query) use ($data) {
                            return $query->where('profesional_id', $data['profesional_id']);
                        })
                        ->exists();
                        
        if ($exists) {
            return response()->json([
                'message' => $data['profesional_id'] ? 
                    'La fecha ya está bloqueada para este profesional.' : 
                    'La fecha ya está bloqueada para todos los profesionales.'
            ], 422);
        }

        $b = Bloqueo::create([
            'fecha' => $data['fecha'], 
            'motivo' => $data['motivo'] ?? null,
            'profesional_id' => $data['profesional_id'] ?? null
        ]);

        return response()->json(['message' => 'Bloqueo creado.', 'bloqueo' => $b]);
    }

    /**
     * Eliminar bloqueo
     */
    public function blocksDestroy($id)
    {
        $b = Bloqueo::find($id);
        if (! $b) {
            return response()->json(['message' => 'Bloqueo no encontrado.'], 404);
        }
        $b->delete();
        return response()->json(['message' => 'Bloqueo eliminado.']);
    }

    /**
     * Página de agradecimiento para booking público
     */
    public function publicThanks()
    {
        return view('booking.thanks');
    }

    /**
     * Devuelve vista parcial del modal de detalle
     */
    public function showModal(Agenda $agenda)
    {
        $cita = $agenda->load(['cliente', 'profesional', 'servicio']);
        return view('admin.agenda.partials.modal-detalle', compact('cita'));
    }

    /**
     * Devuelve vista parcial del modal de reprogramación
     */
    public function showReprogramarModal(Agenda $agenda)
    {
        $cita = $agenda->load(['cliente', 'profesional', 'servicio']);
        return view('admin.agenda.partials.modal-reprogramar', compact('cita'));
    }

    /**
     * Reprogramar desde el formulario modal
     */
    public function updateFromModal(Request $request, Agenda $agenda)
    {
        $data = $request->validate([
            'fecha' => 'required|date',
            'hora_inicio' => 'required|date_format:H:i',
        ]);

        $horaInicio = Carbon::parse($data['hora_inicio']);
        $duracion = $agenda->servicio ? ($agenda->servicio->duracion_minutos ?? 30) : 30;
        $horaFin = $horaInicio->copy()->addMinutes($duracion)->format('H:i:s');

        // validar solapamiento
        $overlap = Agenda::where('id', '!=', $agenda->id)
            ->where('profesional_id', $agenda->profesional_id)
            ->where('fecha', $data['fecha'])
            ->where(function ($q) use ($data, $horaInicio, $horaFin) {
                $q->whereBetween('hora_inicio', [$horaInicio->format('H:i:s'), $horaFin])
                  ->orWhereBetween('hora_fin', [$horaInicio->format('H:i:s'), $horaFin])
                  ->orWhere(function ($q2) use ($horaInicio, $horaFin) {
                      $q2->where('hora_inicio', '<=', $horaInicio->format('H:i:s'))
                         ->where('hora_fin', '>=', $horaFin);
                  });
            })->exists();

        if ($overlap) {
            return response()->json([
                'error' => true,
                'message' => 'La profesional no está disponible en ese horario.'
            ], 422);
        }

        // comprobar bloqueo
        $bloqueado = Bloqueo::where('fecha', $data['fecha'])->exists();
        if ($bloqueado) {
            return response()->json([
                'error' => true,
                'message' => 'La fecha está bloqueada y no se puede reprogramar.'
            ], 422);
        }

        $agenda->fecha = $data['fecha'];
        $agenda->hora_inicio = $horaInicio->format('H:i:s');
        $agenda->hora_fin = $horaFin;
        $agenda->save();

        return response()->json([
            'message' => 'Cita reprogramada correctamente.',
            'cita' => $agenda
        ]);
    }

    // Los métodos resource generics pueden quedarse (create/store/show/edit/update/destroy)
}
